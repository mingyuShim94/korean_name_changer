{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Next.js Project with Tailwind CSS and Shadcn UI",
      "description": "Initialize a new Next.js project with App Router, configure Tailwind CSS, and set up Shadcn UI components library for the Korean Name Changer application.",
      "details": "1. Create a new Next.js project using App Router:\n```bash\nnpx create-next-app@latest korean-name-changer --typescript --tailwind --eslint --app\n```\n2. Navigate to the project directory:\n```bash\ncd korean-name-changer\n```\n3. Install Shadcn UI dependencies:\n```bash\nnpm install shadcn-ui @radix-ui/react-icons class-variance-authority clsx tailwind-merge\n```\n4. Initialize Shadcn UI:\n```bash\nnpx shadcn-ui@latest init\n```\n5. Configure the project structure according to Next.js App Router conventions:\n   - Create appropriate directories in the app folder\n   - Set up layout.tsx with proper metadata\n   - Configure theme and global styles\n6. Create a components directory for reusable UI components",
      "testStrategy": "1. Verify the project builds without errors using `npm run build`\n2. Ensure the development server runs correctly with `npm run dev`\n3. Confirm Tailwind CSS is working by testing a simple component with Tailwind classes\n4. Test that Shadcn UI components can be imported and rendered correctly\n5. Verify the responsive design works on different viewport sizes",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Create Basic Layout and Navigation Structure",
      "description": "Develop the main layout structure for the application including header, main content area, and footer to establish the foundation for the user interface.",
      "details": "1. Create a root layout.tsx file in the app directory:\n```tsx\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body className=\"min-h-screen bg-background font-sans antialiased\">\n        <div className=\"relative flex min-h-screen flex-col\">\n          <header className=\"sticky top-0 z-40 w-full border-b bg-background\">\n            {/* Header content */}\n          </header>\n          <main className=\"flex-1\">{children}</main>\n          <footer className=\"border-t bg-background\">\n            {/* Footer content */}\n          </footer>\n        </div>\n      </body>\n    </html>\n  )\n}\n```\n2. Create a Header component with the application name and navigation\n3. Create a Footer component with copyright information and links\n4. Implement responsive design for all layout components\n5. Add appropriate metadata in the layout for SEO purposes",
      "testStrategy": "1. Verify the layout renders correctly on different screen sizes\n2. Check that the header stays fixed at the top during scrolling\n3. Ensure the footer is always at the bottom of the page\n4. Test navigation links functionality\n5. Validate HTML structure and accessibility using browser dev tools",
      "priority": "high",
      "dependencies": [1],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Name Input UI Component",
      "description": "Create a user-friendly input component that allows users to enter their foreign name, with clear instructions and a submission button.",
      "details": "1. Create a NameInputForm component in the components directory:\n```tsx\n'use client';\n\nimport { useState } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\n\ninterface NameInputFormProps {\n  onSubmit: (name: string) => void;\n  isLoading: boolean;\n}\n\nexport function NameInputForm({ onSubmit, isLoading }: NameInputFormProps) {\n  const [name, setName] = useState('');\n  \n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (name.trim()) {\n      onSubmit(name.trim());\n    }\n  };\n\n  return (\n    <Card className=\"w-full max-w-md mx-auto\">\n      <CardHeader>\n        <CardTitle>Enter Your Name</CardTitle>\n        <CardDescription>\n          Enter your foreign name to get a meaningful Korean name interpretation\n        </CardDescription>\n      </CardHeader>\n      <CardContent>\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n          <Input \n            placeholder=\"e.g. Isabella Rossellini\" \n            value={name} \n            onChange={(e) => setName(e.target.value)}\n            disabled={isLoading}\n            required\n          />\n          <Button \n            type=\"submit\" \n            className=\"w-full\" \n            disabled={isLoading || !name.trim()}\n          >\n            {isLoading ? 'Generating...' : 'Generate Korean Name'}\n          </Button>\n        </form>\n      </CardContent>\n    </Card>\n  );\n}\n```\n2. Implement form validation to ensure the name field is not empty\n3. Add loading state handling for the form submission process\n4. Style the component using Tailwind CSS and Shadcn UI components\n5. Ensure the component is responsive and works well on mobile devices",
      "testStrategy": "1. Test form submission with valid input\n2. Verify form validation prevents empty submissions\n3. Test loading state display during submission\n4. Check responsive design on different screen sizes\n5. Verify accessibility features (keyboard navigation, screen reader compatibility)\n6. Test error handling for edge cases (very long names, special characters)",
      "priority": "high",
      "dependencies": [2],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Design Result Card Component",
      "description": "Create a visually appealing card component to display the generated Korean name and its associated information in a structured and readable format.",
      "details": "1. Create a ResultCard component in the components directory:\n```tsx\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Separator } from '@/components/ui/separator';\n\ninterface HanjaBreakdown {\n  character: string;\n  meaning: string;\n}\n\ninterface KoreanNameResult {\n  original_name: string;\n  korean_name: string;\n  connection_explanation: string;\n  hanja_breakdown: HanjaBreakdown[];\n  poetic_interpretation: string;\n}\n\ninterface ResultCardProps {\n  result: KoreanNameResult;\n}\n\nexport function ResultCard({ result }: ResultCardProps) {\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader>\n        <CardTitle className=\"text-center\">{result.korean_name}</CardTitle>\n        <CardDescription className=\"text-center\">Korean name for {result.original_name}</CardDescription>\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        <div>\n          <h3 className=\"text-lg font-semibold mb-2\">Connection</h3>\n          <p>{result.connection_explanation}</p>\n        </div>\n        \n        <Separator />\n        \n        <div>\n          <h3 className=\"text-lg font-semibold mb-2\">Hanja Characters</h3>\n          <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n            {result.hanja_breakdown.map((hanja, index) => (\n              <div key={index} className=\"border rounded-lg p-4 text-center\">\n                <div className=\"text-3xl mb-2\">{hanja.character}</div>\n                <p className=\"text-sm\">{hanja.meaning}</p>\n              </div>\n            ))}\n          </div>\n        </div>\n        \n        <Separator />\n        \n        <div>\n          <h3 className=\"text-lg font-semibold mb-2\">Poetic Interpretation</h3>\n          <p className=\"italic\">{result.poetic_interpretation}</p>\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n```\n2. Implement responsive design for different screen sizes\n3. Add subtle animations or transitions for better user experience\n4. Ensure proper spacing and typography for readability\n5. Use appropriate color schemes and visual hierarchy to highlight important information",
      "testStrategy": "1. Test rendering with sample data matching the expected JSON structure\n2. Verify all sections (connection explanation, hanja breakdown, poetic interpretation) display correctly\n3. Check responsive design on different screen sizes\n4. Ensure proper handling of long text content\n5. Verify accessibility features (color contrast, semantic HTML)\n6. Test with edge cases (missing fields, extra long content)",
      "priority": "high",
      "dependencies": [2],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Setup Gemini API Integration",
      "description": "Implement the integration with Google Gemini API to generate Korean names based on user input, including proper error handling and response parsing.",
      "details": "1. Create a .env.local file to store the Gemini API key:\n```\nGEMINI_API_KEY=your_api_key_here\n```\n2. Install the Google Generative AI SDK:\n```bash\nnpm install @google/generative-ai\n```\n3. Create a lib/gemini.ts file for API integration:\n```typescript\nimport { GoogleGenerativeAI } from '@google/generative-ai';\n\n// Initialize the Gemini API client\nconst genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || '');\n\n// Define the expected response structure\nexport interface KoreanNameResult {\n  original_name: string;\n  korean_name: string;\n  connection_explanation: string;\n  hanja_breakdown: {\n    character: string;\n    meaning: string;\n  }[];\n  poetic_interpretation: string;\n}\n\n// Create the system prompt\nconst systemPrompt = `You are a poetic Korean name generator that creates meaningful Korean names for foreigners.\nWhen given a foreign name, analyze its etymology, meaning, and cultural significance.\nThen create a Korean name (including surname) that captures the essence and meaning of the original name.\nYour response must be a valid JSON object with the following structure:\n{\n  \"original_name\": \"The input name\",\n  \"korean_name\": \"The Korean name with Hanja and romanization in parentheses\",\n  \"connection_explanation\": \"Detailed explanation of how the Korean name connects to the original name\",\n  \"hanja_breakdown\": [\n    {\n      \"character\": \"The Hanja character\",\n      \"meaning\": \"The meaning of this specific Hanja character\"\n    }\n  ],\n  \"poetic_interpretation\": \"A poetic description of the name's overall meaning and imagery\"\n}\nUse traditional and meaningful Korean surnames like Kim, Lee, Park, Choi, etc.\nChoose Hanja characters that have positive meanings and are commonly used in Korean names.\nProvide romanization in the Revised Romanization system.\nMake the connection between the original name and Korean name meaningful, not just phonetic.`;\n\nexport async function generateKoreanName(foreignName: string): Promise<KoreanNameResult> {\n  try {\n    // Get the Gemini Pro model\n    const model = genAI.getGenerativeModel({ model: 'gemini-pro' });\n    \n    // Generate content with the system prompt and user input\n    const result = await model.generateContent([\n      systemPrompt,\n      `Generate a Korean name for: ${foreignName}`\n    ]);\n    \n    const response = result.response;\n    const text = response.text();\n    \n    // Parse the JSON response\n    try {\n      const parsedResult = JSON.parse(text) as KoreanNameResult;\n      return parsedResult;\n    } catch (parseError) {\n      console.error('Failed to parse Gemini API response:', parseError);\n      throw new Error('Invalid response format from AI service');\n    }\n  } catch (error) {\n    console.error('Error calling Gemini API:', error);\n    throw new Error('Failed to generate Korean name');\n  }\n}\n```\n4. Create an API route in app/api/generate-name/route.ts:\n```typescript\nimport { NextRequest, NextResponse } from 'next/server';\nimport { generateKoreanName } from '@/lib/gemini';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { name } = body;\n    \n    if (!name || typeof name !== 'string') {\n      return NextResponse.json(\n        { error: 'Name is required' },\n        { status: 400 }\n      );\n    }\n    \n    const result = await generateKoreanName(name);\n    return NextResponse.json(result);\n  } catch (error) {\n    console.error('Error in generate-name API route:', error);\n    return NextResponse.json(\n      { error: 'Failed to generate Korean name' },\n      { status: 500 }\n    );\n  }\n}\n```",
      "testStrategy": "1. Test the API integration with valid input names\n2. Verify error handling for API failures\n3. Test response parsing with sample JSON responses\n4. Check handling of rate limiting and other API constraints\n5. Verify the API route returns proper error responses for invalid inputs\n6. Test with various name formats (first name only, full name, names with special characters)\n7. Create a mock implementation for development and testing purposes",
      "priority": "high",
      "dependencies": [1],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Main Page with Name Generation Flow",
      "description": "Create the main page that integrates the name input form and result display, managing the state and API calls for the name generation process.",
      "details": "1. Create the main page component in app/page.tsx:\n```tsx\n'use client';\n\nimport { useState } from 'react';\nimport { NameInputForm } from '@/components/name-input-form';\nimport { ResultCard } from '@/components/result-card';\nimport { Button } from '@/components/ui/button';\nimport { KoreanNameResult } from '@/lib/gemini';\nimport { useToast } from '@/components/ui/use-toast';\n\nexport default function HomePage() {\n  const [isLoading, setIsLoading] = useState(false);\n  const [result, setResult] = useState<KoreanNameResult | null>(null);\n  const { toast } = useToast();\n\n  const handleSubmit = async (name: string) => {\n    setIsLoading(true);\n    try {\n      const response = await fetch('/api/generate-name', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ name }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || 'Failed to generate name');\n      }\n\n      const data = await response.json();\n      setResult(data);\n    } catch (error) {\n      console.error('Error generating name:', error);\n      toast({\n        title: 'Error',\n        description: error instanceof Error ? error.message : 'Failed to generate Korean name',\n        variant: 'destructive',\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleReset = () => {\n    setResult(null);\n  };\n\n  return (\n    <div className=\"container mx-auto py-10 px-4 max-w-4xl\">\n      <div className=\"text-center mb-10\">\n        <h1 className=\"text-3xl font-bold tracking-tight mb-2\">Korean Name Changer</h1>\n        <p className=\"text-muted-foreground\">\n          Discover your poetic Korean name based on the meaning and essence of your original name\n        </p>\n      </div>\n\n      {!result ? (\n        <NameInputForm onSubmit={handleSubmit} isLoading={isLoading} />\n      ) : (\n        <div className=\"space-y-6\">\n          <ResultCard result={result} />\n          <div className=\"flex justify-center\">\n            <Button onClick={handleReset} variant=\"outline\">\n              Try Another Name\n            </Button>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n```\n2. Implement loading states and error handling\n3. Add toast notifications for success and error states\n4. Create a smooth transition between input and result views\n5. Implement the \"Try Another Name\" functionality to reset the form",
      "testStrategy": "1. Test the complete flow from name input to result display\n2. Verify loading states are displayed correctly during API calls\n3. Test error handling with simulated API failures\n4. Check the reset functionality works correctly\n5. Verify the UI updates appropriately based on application state\n6. Test with various input scenarios (valid names, empty input, etc.)\n7. Verify toast notifications appear correctly for errors",
      "priority": "high",
      "dependencies": [3, 4, 5],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Session History Feature",
      "description": "Create a feature to store and display previously generated names within the current session using browser session storage.",
      "details": "1. Create a custom hook for managing session history in hooks/useNameHistory.ts:\n```typescript\nimport { useState, useEffect } from 'react';\nimport { KoreanNameResult } from '@/lib/gemini';\n\nexport function useNameHistory() {\n  const [history, setHistory] = useState<KoreanNameResult[]>([]);\n\n  // Load history from session storage on initial render\n  useEffect(() => {\n    try {\n      const savedHistory = sessionStorage.getItem('nameHistory');\n      if (savedHistory) {\n        setHistory(JSON.parse(savedHistory));\n      }\n    } catch (error) {\n      console.error('Error loading history from session storage:', error);\n    }\n  }, []);\n\n  // Save history to session storage whenever it changes\n  useEffect(() => {\n    try {\n      sessionStorage.setItem('nameHistory', JSON.stringify(history));\n    } catch (error) {\n      console.error('Error saving history to session storage:', error);\n    }\n  }, [history]);\n\n  const addToHistory = (result: KoreanNameResult) => {\n    // Add to history only if it doesn't already exist\n    setHistory(prev => {\n      const exists = prev.some(item => \n        item.original_name === result.original_name && \n        item.korean_name === result.korean_name\n      );\n      \n      if (exists) return prev;\n      return [result, ...prev];\n    });\n  };\n\n  const clearHistory = () => {\n    setHistory([]);\n    sessionStorage.removeItem('nameHistory');\n  };\n\n  return { history, addToHistory, clearHistory };\n}\n```\n2. Create a HistoryList component in components/history-list.tsx:\n```tsx\nimport { KoreanNameResult } from '@/lib/gemini';\nimport { Button } from '@/components/ui/button';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';\n\ninterface HistoryListProps {\n  history: KoreanNameResult[];\n  onSelect: (result: KoreanNameResult) => void;\n  onClear: () => void;\n}\n\nexport function HistoryList({ history, onSelect, onClear }: HistoryListProps) {\n  if (history.length === 0) {\n    return null;\n  }\n\n  return (\n    <Card className=\"w-full max-w-md mx-auto\">\n      <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n        <CardTitle className=\"text-xl\">Previous Names</CardTitle>\n        <Button variant=\"ghost\" size=\"sm\" onClick={onClear}>\n          Clear All\n        </Button>\n      </CardHeader>\n      <CardContent>\n        <ScrollArea className=\"h-[250px] pr-4\">\n          <div className=\"space-y-2\">\n            {history.map((item, index) => (\n              <div \n                key={index} \n                className=\"p-3 border rounded-md cursor-pointer hover:bg-accent transition-colors\"\n                onClick={() => onSelect(item)}\n              >\n                <div className=\"font-medium\">{item.korean_name}</div>\n                <div className=\"text-sm text-muted-foreground\">{item.original_name}</div>\n              </div>\n            ))}\n          </div>\n        </ScrollArea>\n      </CardContent>\n    </Card>\n  );\n}\n```\n3. Update the main page to include history functionality:\n```tsx\n// Add to imports\nimport { useNameHistory } from '@/hooks/useNameHistory';\nimport { HistoryList } from '@/components/history-list';\n\n// Inside the HomePage component\nconst { history, addToHistory, clearHistory } = useNameHistory();\n\n// Update handleSubmit to add results to history\nconst handleSubmit = async (name: string) => {\n  // ... existing code ...\n  \n  const data = await response.json();\n  setResult(data);\n  addToHistory(data); // Add this line\n  \n  // ... existing code ...\n};\n\n// Add to the JSX, after the main content\n{!result && history.length > 0 && (\n  <div className=\"mt-10\">\n    <HistoryList \n      history={history} \n      onSelect={setResult} \n      onClear={clearHistory} \n    />\n  </div>\n)}\n```",
      "testStrategy": "1. Test adding new results to history\n2. Verify history persists across page refreshes within the same session\n3. Test selecting items from history displays the correct result\n4. Verify the clear history functionality works correctly\n5. Test edge cases like session storage limits\n6. Check that duplicate entries are not added to history\n7. Verify the history list is only shown when appropriate (when there's no current result)",
      "priority": "medium",
      "dependencies": [6],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Loading and Error States",
      "description": "Create loading indicators, error messages, and fallback states to improve user experience during API calls and error scenarios.",
      "details": "1. Create a LoadingSpinner component in components/loading-spinner.tsx:\n```tsx\nexport function LoadingSpinner({ className = '' }: { className?: string }) {\n  return (\n    <div className={`flex justify-center items-center ${className}`}>\n      <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary\"></div>\n    </div>\n  );\n}\n```\n2. Create an ErrorMessage component in components/error-message.tsx:\n```tsx\nimport { AlertCircle } from 'lucide-react';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\n\ninterface ErrorMessageProps {\n  title?: string;\n  message: string;\n}\n\nexport function ErrorMessage({ title = 'Error', message }: ErrorMessageProps) {\n  return (\n    <Alert variant=\"destructive\">\n      <AlertCircle className=\"h-4 w-4\" />\n      <AlertTitle>{title}</AlertTitle>\n      <AlertDescription>{message}</AlertDescription>\n    </Alert>\n  );\n}\n```\n3. Create a LoadingCard component for the name generation process:\n```tsx\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { LoadingSpinner } from '@/components/loading-spinner';\n\nexport function LoadingCard() {\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\">\n      <CardHeader>\n        <CardTitle className=\"text-center\">Generating Your Korean Name</CardTitle>\n      </CardHeader>\n      <CardContent className=\"flex flex-col items-center py-10\">\n        <LoadingSpinner className=\"mb-4\" />\n        <p className=\"text-center text-muted-foreground\">\n          Our AI is crafting a meaningful Korean name based on your original name's essence...\n        </p>\n      </CardContent>\n    </Card>\n  );\n}\n```\n4. Update the main page to use these components:\n```tsx\n// Add to imports\nimport { LoadingCard } from '@/components/loading-card';\nimport { ErrorMessage } from '@/components/error-message';\n\n// Add state for error handling\nconst [error, setError] = useState<string | null>(null);\n\n// Update handleSubmit for error handling\nconst handleSubmit = async (name: string) => {\n  setIsLoading(true);\n  setError(null); // Reset error state\n  try {\n    // ... existing code ...\n  } catch (error) {\n    console.error('Error generating name:', error);\n    setError(error instanceof Error ? error.message : 'Failed to generate Korean name');\n    // Remove toast if using ErrorMessage component instead\n  } finally {\n    setIsLoading(false);\n  }\n};\n\n// Update the JSX to show loading and error states\nreturn (\n  <div className=\"container mx-auto py-10 px-4 max-w-4xl\">\n    {/* ... existing header ... */}\n    \n    {error && (\n      <div className=\"mb-6\">\n        <ErrorMessage message={error} />\n      </div>\n    )}\n    \n    {isLoading ? (\n      <LoadingCard />\n    ) : !result ? (\n      <NameInputForm onSubmit={handleSubmit} isLoading={isLoading} />\n    ) : (\n      <div className=\"space-y-6\">\n        <ResultCard result={result} />\n        <div className=\"flex justify-center\">\n          <Button onClick={handleReset} variant=\"outline\">\n            Try Another Name\n          </Button>\n        </div>\n      </div>\n    )}\n    \n    {/* ... history section ... */}\n  </div>\n);\n```",
      "testStrategy": "1. Test loading states appear during API calls\n2. Verify error messages display correctly when API calls fail\n3. Test error handling with various error scenarios (network errors, API errors, etc.)\n4. Check that error states are properly reset when retrying\n5. Verify loading indicators are accessible and provide good user feedback\n6. Test the transition between loading, error, and success states\n7. Verify error messages are clear and actionable for users",
      "priority": "medium",
      "dependencies": [6],
      "status": "in-progress",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Responsive Design and Mobile Optimization",
      "description": "Ensure the application is fully responsive and provides an optimal user experience across different devices and screen sizes.",
      "details": "1. Review and update all components for responsive design:\n   - Use Tailwind's responsive classes (sm:, md:, lg:, etc.)\n   - Ensure text sizes are appropriate for different screens\n   - Adjust spacing and layout for mobile devices\n\n2. Update the main layout for better mobile experience:\n```tsx\n// In layout.tsx or page.tsx\n<div className=\"container mx-auto py-6 px-4 md:py-10 md:px-6 max-w-4xl\">\n  {/* Content */}\n</div>\n```\n\n3. Optimize the ResultCard component for mobile:\n```tsx\n// Update the Hanja breakdown section\n<div className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4\">\n  {result.hanja_breakdown.map((hanja, index) => (\n    <div key={index} className=\"border rounded-lg p-3 md:p-4 text-center\">\n      <div className=\"text-2xl md:text-3xl mb-1 md:mb-2\">{hanja.character}</div>\n      <p className=\"text-xs md:text-sm\">{hanja.meaning}</p>\n    </div>\n  ))}\n</div>\n```\n\n4. Add a responsive typography utility in styles/globals.css:\n```css\n@layer utilities {\n  .text-responsive {\n    font-size: clamp(1rem, 0.95rem + 0.25vw, 1.25rem);\n  }\n}\n```\n\n5. Implement touch-friendly interactions for mobile users:\n```tsx\n// Example for history items\n<div \n  key={index} \n  className=\"p-3 border rounded-md cursor-pointer hover:bg-accent active:bg-accent/90 transition-colors\"\n  onClick={() => onSelect(item)}\n>\n  {/* Content */}\n</div>\n```\n\n6. Add meta viewport tag in layout.tsx:\n```tsx\nexport const metadata = {\n  title: 'Korean Name Changer',\n  description: 'Discover your poetic Korean name based on the meaning of your original name',\n  viewport: 'width=device-width, initial-scale=1, maximum-scale=1',\n};\n```\n\n7. Test and optimize for various device sizes using browser dev tools",
      "testStrategy": "1. Test the application on various device sizes (mobile, tablet, desktop)\n2. Verify text remains readable on small screens\n3. Check that interactive elements are appropriately sized for touch input\n4. Test navigation and user flows on mobile devices\n5. Verify that content doesn't overflow or cause horizontal scrolling\n6. Test with different orientations (portrait/landscape)\n7. Verify loading and error states display properly on mobile\n8. Use Chrome DevTools device emulation for testing different devices",
      "priority": "medium",
      "dependencies": [6],
      "status": "in-progress",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Implement Share Functionality",
      "description": "Add the ability for users to share their generated Korean name results via social media, copy to clipboard, or download as an image.",
      "details": "1. Create a ShareButton component in components/share-button.tsx:\n```tsx\n'use client';\n\nimport { useState } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Share, Copy, Check, Download } from 'lucide-react';\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\nimport { KoreanNameResult } from '@/lib/gemini';\nimport { useToast } from '@/components/ui/use-toast';\nimport html2canvas from 'html2canvas';\n\ninterface ShareButtonProps {\n  result: KoreanNameResult;\n  resultCardRef: React.RefObject<HTMLDivElement>;\n}\n\nexport function ShareButton({ result, resultCardRef }: ShareButtonProps) {\n  const [copied, setCopied] = useState(false);\n  const [isDownloading, setIsDownloading] = useState(false);\n  const { toast } = useToast();\n\n  const shareText = `My Korean name is ${result.korean_name}\\n${result.poetic_interpretation}\\nGenerated by Korean Name Changer`;\n\n  const handleCopy = async () => {\n    try {\n      await navigator.clipboard.writeText(shareText);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    } catch (error) {\n      toast({\n        title: 'Error',\n        description: 'Failed to copy to clipboard',\n        variant: 'destructive',\n      });\n    }\n  };\n\n  const handleDownloadImage = async () => {\n    if (!resultCardRef.current) return;\n    \n    setIsDownloading(true);\n    try {\n      const canvas = await html2canvas(resultCardRef.current, {\n        backgroundColor: '#ffffff',\n        scale: 2, // Higher quality\n      });\n      \n      const image = canvas.toDataURL('image/png');\n      const link = document.createElement('a');\n      link.href = image;\n      link.download = `korean-name-${result.original_name.replace(/\\s+/g, '-').toLowerCase()}.png`;\n      link.click();\n      \n      toast({\n        title: 'Success',\n        description: 'Image downloaded successfully',\n      });\n    } catch (error) {\n      toast({\n        title: 'Error',\n        description: 'Failed to download image',\n        variant: 'destructive',\n      });\n    } finally {\n      setIsDownloading(false);\n    }\n  };\n\n  const handleShare = async () => {\n    if (!navigator.share) {\n      toast({\n        title: 'Error',\n        description: 'Web Share API is not supported in your browser',\n        variant: 'destructive',\n      });\n      return;\n    }\n    \n    try {\n      await navigator.share({\n        title: 'My Korean Name',\n        text: shareText,\n        url: window.location.href,\n      });\n    } catch (error) {\n      if (error instanceof Error && error.name !== 'AbortError') {\n        toast({\n          title: 'Error',\n          description: 'Failed to share',\n          variant: 'destructive',\n        });\n      }\n    }\n  };\n\n  return (\n    <Popover>\n      <PopoverTrigger asChild>\n        <Button variant=\"outline\" size=\"sm\" className=\"flex items-center gap-2\">\n          <Share className=\"h-4 w-4\" />\n          <span>Share</span>\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-56\" align=\"end\">\n        <div className=\"grid gap-2\">\n          <Button \n            variant=\"outline\" \n            size=\"sm\" \n            className=\"justify-start\" \n            onClick={handleCopy}\n          >\n            {copied ? <Check className=\"h-4 w-4 mr-2\" /> : <Copy className=\"h-4 w-4 mr-2\" />}\n            {copied ? 'Copied!' : 'Copy to clipboard'}\n          </Button>\n          \n          <Button \n            variant=\"outline\" \n            size=\"sm\" \n            className=\"justify-start\" \n            onClick={handleDownloadImage}\n            disabled={isDownloading}\n          >\n            <Download className=\"h-4 w-4 mr-2\" />\n            {isDownloading ? 'Downloading...' : 'Download as image'}\n          </Button>\n          \n          {navigator.share && (\n            <Button \n              variant=\"outline\" \n              size=\"sm\" \n              className=\"justify-start\" \n              onClick={handleShare}\n            >\n              <Share className=\"h-4 w-4 mr-2\" />\n              Share\n            </Button>\n          )}\n        </div>\n      </PopoverContent>\n    </Popover>\n  );\n}\n```\n\n2. Install html2canvas for image generation:\n```bash\nnpm install html2canvas\n```\n\n3. Update the ResultCard component to include a ref and share button:\n```tsx\n// Add to imports\nimport { forwardRef } from 'react';\nimport { ShareButton } from '@/components/share-button';\n\n// Update component definition\nexport const ResultCard = forwardRef<HTMLDivElement, ResultCardProps>(({ result }, ref) => {\n  return (\n    <Card className=\"w-full max-w-2xl mx-auto\" ref={ref}>\n      <CardHeader className=\"flex flex-row items-start justify-between\">\n        <div>\n          <CardTitle className=\"text-center\">{result.korean_name}</CardTitle>\n          <CardDescription className=\"text-center\">Korean name for {result.original_name}</CardDescription>\n        </div>\n        <ShareButton result={result} resultCardRef={ref as React.RefObject<HTMLDivElement>} />\n      </CardHeader>\n      {/* Rest of the component remains the same */}\n    </Card>\n  );\n});\nResultCard.displayName = 'ResultCard';\n```\n\n4. Update the main page to use the ref:\n```tsx\n// Add to imports\nimport { useRef } from 'react';\n\n// Inside the component\nconst resultCardRef = useRef<HTMLDivElement>(null);\n\n// Update the JSX\n<ResultCard result={result} ref={resultCardRef} />\n```",
      "testStrategy": "1. Test copying to clipboard functionality\n2. Verify image download works correctly and produces a high-quality image\n3. Test Web Share API on supported devices/browsers\n4. Verify proper error handling when sharing features are not supported\n5. Test with different result content (long names, special characters)\n6. Check that toast notifications appear correctly for success/error states\n7. Verify the share popover displays and positions correctly\n8. Test on different devices to ensure cross-platform compatibility",
      "priority": "low",
      "dependencies": [6],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Fallback/Mock Data for Development",
      "description": "Create a fallback mechanism with mock data for development and testing purposes, to avoid API calls during development and handle API failures gracefully.",
      "details": "1. Create a mock data file in lib/mock-data.ts:\n```typescript\nimport { KoreanNameResult } from './gemini';\n\nexport const MOCK_RESULTS: Record<string, KoreanNameResult> = {\n  'sophia loren': {\n    original_name: 'Sophia Loren',\n    korean_name: '이예지 (李藝智, Lee Ye-ji)',\n    connection_explanation: '\\'소피아\\'라는 이름은 그리스어로 \\'지혜\\'를 의미하며, 깊은 이해와 통찰력을 나타냅니다. 이는 \\'예술적 지혜\\' 또는 \\'교양 있는 지성\\'을 의미하는 한국 이름 \\'예지(藝智)\\'에 영감을 주었습니다. 성씨 \\'로렌\\'은 시대를 초월하는 우아함과 고전적인 아름다움을 연상시키는데, 이는 \\'자두나무\\'를 원래 의미하며 우아한 전통과 회복력을 전달하는 한국의 흔하고 역사적으로 중요한 성씨 \\'이(李)\\'와 유사합니다.',\n    hanja_breakdown: [\n      {\n        character: '李',\n        meaning: '자두나무를 참조하며, 굳건함과 고전적인 우아함을 상징하는 널리 퍼진 전통적인 한국 성씨입니다.'\n      },\n      {\n        character: '藝',\n        meaning: '예술, 기술, 재능, 교양 — 소피아 로렌의 거장다운 예술성과 세련된 존재감을 반영합니다.'\n      },\n      {\n        character: '智',\n        meaning: '지혜, 지성 — 원래 이름 \\'소피아\\'의 의미와 직접적으로 일치합니다.'\n      }\n    ],\n    poetic_interpretation: '\\'이예지\\'는 깊은 통찰력과 예술적 우아함을 모두 갖춘 지혜롭고 교양 있는 정신의 이미지를 구현합니다. 이는 마치 조용하고 지적인 아름다움으로 피어나는 자두나무처럼, 심오한 내면의 힘과 결합된 고전적인 아름다움의 본질을 포착합니다.'\n  },\n  'john smith': {\n    original_name: 'John Smith',\n    korean_name: '김진성 (金眞誠, Kim Jin-seong)',\n    connection_explanation: '\\'존\\'은 히브리어 기원으로 \\'하느님은 자비롭다\\'라는 의미를 가지며, 신실함과 은혜를 상징합니다. 이는 \\'진실함\\'과 \\'성실함\\'을 의미하는 한국 이름 \\'진성(眞誠)\\'으로 연결됩니다. \\'스미스\\'는 원래 \\'대장장이\\'를 의미하는 직업 성씨로, 장인 정신과 금속 작업을 나타냅니다. 이는 \\'금(金)\\'의 의미를 가진 한국의 가장 흔한 성씨 중 하나인 \\'김(金)\\'과 자연스럽게 연결됩니다.',\n    hanja_breakdown: [\n      {\n        character: '金',\n        meaning: '금속, 금 - 스미스(대장장이)의 직업적 의미와 직접 연결되며, 한국에서 가장 흔한 성씨 중 하나입니다.'\n      },\n      {\n        character: '眞',\n        meaning: '진실, 진짜, 참됨 - 존 이름의 신실함과 진정성을 반영합니다.'\n      },\n      {\n        character: '誠',\n        meaning: '성실, 진심, 정직 - 존 이름의 덕성과 도덕적 품질을 보완합니다.'\n      }\n    ],\n    poetic_interpretation: '\\'김진성\\'은 금속처럼 단단하고 변함없는 진실성과 성실함을 가진 사람을 묘사합니다. 이는 대장장이가 쇠를 정성껏 다루어 가치 있는 물건으로 변화시키듯, 진실된 마음으로 세상에 의미 있는 기여를 하는 사람의 모습을 떠올리게 합니다.'\n  },\n  'isabella rossellini': {\n    original_name: 'Isabella Rossellini',\n    korean_name: '박서연 (朴瑞燕, Park Seo-yeon)',\n    connection_explanation: '\\'이사벨라\\'는 히브리어 \\'엘리자베스\\'의 변형으로 \\'신께 헌신한\\'이라는 의미를 가지며, 우아함과 고귀함을 상징합니다. 이는 \\'상서로움\\'과 \\'아름다움\\'을 의미하는 한국 이름 \\'서연(瑞燕)\\'으로 해석됩니다. \\'로셀리니\\'는 이탈리아 성으로 \\'작은 빨간 것\\'을 의미하며 예술적 열정을 연상시킵니다. 이는 견고함과 신뢰성을 상징하는 한국의 대표적 성씨 \\'박(朴)\\'과 연결됩니다.',\n    hanja_breakdown: [\n      {\n        character: '朴',\n        meaning: '소박함, 단순함, 진실함 - 자연스러운 우아함과 진정성을 나타내는 전통적인 한국 성씨입니다.'\n      },\n      {\n        character: '瑞',\n        meaning: '상서로움, 행운, 좋은 징조 - 이사벨라의 고귀한 특성과 축복받은 존재감을 반영합니다.'\n      },\n      {\n        character: '燕',\n        meaning: '제비, 우아함 - 로셀리니의 예술적 감각과 세련된 아름다움을 상징합니다.'\n      }\n    ],\n    poetic_interpretation: '\\'박서연\\'은 소박하면서도 깊은 아름다움을 지닌 사람을 묘사합니다. 마치 우아하게 날아다니는 제비처럼 자유롭고 예술적인 영혼을 가졌으며, 그 존재만으로도 주변에 행운과 기쁨을 가져다주는 사람입니다. 이는 자연스러운 우아함과 진정성 있는 예술적 표현이 조화를 이루는 모습을 떠올리게 합니다.'\n  }\n};\n\n// Default mock result for fallback\nexport const DEFAULT_MOCK_RESULT: KoreanNameResult = MOCK_RESULTS['sophia loren'];\n\n// Function to get mock result\nexport function getMockResult(name: string): KoreanNameResult {\n  const normalizedName = name.toLowerCase().trim();\n  \n  // Check if we have a specific mock for this name\n  for (const [mockName, result] of Object.entries(MOCK_RESULTS)) {\n    if (normalizedName.includes(mockName)) {\n      return result;\n    }\n  }\n  \n  // If no specific mock found, return a default with the original name updated\n  return {\n    ...DEFAULT_MOCK_RESULT,\n    original_name: name\n  };\n}\n```\n\n2. Update the API route to use mock data in development:\n```typescript\nimport { NextRequest, NextResponse } from 'next/server';\nimport { generateKoreanName } from '@/lib/gemini';\nimport { getMockResult } from '@/lib/mock-data';\n\n// Environment flag for using mock data\nconst USE_MOCK_DATA = process.env.NODE_ENV === 'development' && process.env.USE_REAL_API !== 'true';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { name } = body;\n    \n    if (!name || typeof name !== 'string') {\n      return NextResponse.json(\n        { error: 'Name is required' },\n        { status: 400 }\n      );\n    }\n    \n    // Use mock data in development unless explicitly told to use real API\n    if (USE_MOCK_DATA) {\n      // Simulate network delay\n      await new Promise(resolve => setTimeout(resolve, 1500));\n      const mockResult = getMockResult(name);\n      return NextResponse.json(mockResult);\n    }\n    \n    // Use real API\n    const result = await generateKoreanName(name);\n    return NextResponse.json(result);\n  } catch (error) {\n    console.error('Error in generate-name API route:', error);\n    return NextResponse.json(\n      { error: 'Failed to generate Korean name' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n3. Create a .env.local file with configuration options:\n```\nGEMINI_API_KEY=your_api_key_here\n# Set to 'true' to use real API in development\nUSE_REAL_API=false\n```\n\n4. Add a fallback mechanism in the generateKoreanName function:\n```typescript\nimport { DEFAULT_MOCK_RESULT } from './mock-data';\n\nexport async function generateKoreanName(foreignName: string): Promise<KoreanNameResult> {\n  try {\n    // Existing implementation...\n  } catch (error) {\n    console.error('Error calling Gemini API:', error);\n    \n    // In production, rethrow the error\n    if (process.env.NODE_ENV === 'production') {\n      throw new Error('Failed to generate Korean name');\n    }\n    \n    // In development, return mock data as fallback\n    console.warn('Using mock data as fallback due to API error');\n    return {\n      ...DEFAULT_MOCK_RESULT,\n      original_name: foreignName\n    };\n  }\n}\n```",
      "testStrategy": "1. Test the application with mock data enabled\n2. Verify that mock data is used in development mode\n3. Test switching between mock and real API using environment variables\n4. Verify that the mock data provides a realistic representation of the API response\n5. Test the fallback mechanism when API calls fail\n6. Verify that the simulated network delay provides a realistic loading experience\n7. Test with various input names to see how the mock system handles them",
      "priority": "medium",
      "dependencies": [5],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement Analytics and Logging",
      "description": "Add basic analytics tracking and error logging to monitor application usage and identify issues in production.",
      "details": "1. Create a simple analytics service in lib/analytics.ts:\n```typescript\n// Simple analytics service\n\n// Types for analytics events\ntype EventName = 'page_view' | 'name_generated' | 'error' | 'share';\n\ninterface AnalyticsEvent {\n  name: EventName;\n  properties?: Record<string, any>;\n  timestamp?: number;\n}\n\n// In a real app, you would integrate with a service like Google Analytics,\n// Mixpanel, Posthog, etc. This is a simple implementation for demonstration.\nclass AnalyticsService {\n  private enabled: boolean;\n  \n  constructor() {\n    // Only enable in production or if explicitly enabled\n    this.enabled = process.env.NODE_ENV === 'production' || process.env.NEXT_PUBLIC_ENABLE_ANALYTICS === 'true';\n  }\n  \n  // Track an event\n  track(event: AnalyticsEvent): void {\n    if (!this.enabled) return;\n    \n    const eventWithTimestamp = {\n      ...event,\n      timestamp: event.timestamp || Date.now(),\n    };\n    \n    // In a real implementation, send to analytics service\n    console.log('[Analytics]', eventWithTimestamp);\n    \n    // Example implementation for sending to a backend endpoint\n    try {\n      if (typeof window !== 'undefined') {\n        // Use sendBeacon for better reliability when available\n        if (navigator.sendBeacon) {\n          navigator.sendBeacon(\n            '/api/analytics',\n            JSON.stringify(eventWithTimestamp)\n          );\n        } else {\n          // Fallback to fetch\n          fetch('/api/analytics', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(eventWithTimestamp),\n            // Use keepalive to ensure the request completes even if the page is unloading\n            keepalive: true,\n          }).catch(err => console.error('Analytics error:', err));\n        }\n      }\n    } catch (error) {\n      // Silently fail for analytics errors\n      console.error('Failed to send analytics:', error);\n    }\n  }\n  \n  // Track page view\n  trackPageView(path?: string): void {\n    const currentPath = path || (typeof window !== 'undefined' ? window.location.pathname : '');\n    \n    this.track({\n      name: 'page_view',\n      properties: {\n        path: currentPath,\n        referrer: typeof document !== 'undefined' ? document.referrer : '',\n      },\n    });\n  }\n  \n  // Track name generation\n  trackNameGenerated(originalName: string, success: boolean): void {\n    this.track({\n      name: 'name_generated',\n      properties: {\n        original_name: originalName,\n        success,\n      },\n    });\n  }\n  \n  // Track error\n  trackError(errorMessage: string, context?: Record<string, any>): void {\n    this.track({\n      name: 'error',\n      properties: {\n        error_message: errorMessage,\n        ...context,\n      },\n    });\n  }\n  \n  // Track share\n  trackShare(method: string): void {\n    this.track({\n      name: 'share',\n      properties: {\n        method,\n      },\n    });\n  }\n}\n\n// Create a singleton instance\nexport const analytics = new AnalyticsService();\n```\n\n2. Create an API route for analytics in app/api/analytics/route.ts:\n```typescript\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    \n    // In a real implementation, you would process and store the analytics data\n    // or forward it to an analytics service\n    console.log('[Server Analytics]', body);\n    \n    // For now, just log it and return success\n    return NextResponse.json({ success: true });\n  } catch (error) {\n    console.error('Error processing analytics:', error);\n    return NextResponse.json({ success: false }, { status: 500 });\n  }\n}\n```\n\n3. Create an error logging service in lib/error-logger.ts:\n```typescript\nimport { analytics } from './analytics';\n\n// Simple error logging service\nclass ErrorLogger {\n  private enabled: boolean;\n  \n  constructor() {\n    // Enable in all environments but can be disabled\n    this.enabled = process.env.NEXT_PUBLIC_DISABLE_ERROR_LOGGING !== 'true';\n  }\n  \n  // Log an error\n  logError(error: Error | string, context?: Record<string, any>): void {\n    if (!this.enabled) return;\n    \n    const errorMessage = error instanceof Error ? error.message : error;\n    const errorStack = error instanceof Error ? error.stack : undefined;\n    \n    // Log to console in all environments\n    console.error('[Error]', errorMessage, context, errorStack);\n    \n    // Track in analytics\n    analytics.trackError(errorMessage, {\n      ...context,\n      stack: errorStack,\n    });\n    \n    // In a real app, you might send to a service like Sentry, LogRocket, etc.\n  }\n}\n\n// Create a singleton instance\nexport const errorLogger = new ErrorLogger();\n```\n\n4. Update the main page to use analytics and error logging:\n```tsx\n// Add to imports\nimport { useEffect } from 'react';\nimport { analytics } from '@/lib/analytics';\nimport { errorLogger } from '@/lib/error-logger';\n\n// Inside the HomePage component\n\n// Track page view on mount\nuseEffect(() => {\n  analytics.trackPageView();\n}, []);\n\n// Update handleSubmit to track name generation\nconst handleSubmit = async (name: string) => {\n  setIsLoading(true);\n  setError(null);\n  try {\n    const response = await fetch('/api/generate-name', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ name }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.error || 'Failed to generate name');\n    }\n\n    const data = await response.json();\n    setResult(data);\n    addToHistory(data);\n    \n    // Track successful name generation\n    analytics.trackNameGenerated(name, true);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Failed to generate Korean name';\n    setError(errorMessage);\n    \n    // Log the error\n    errorLogger.logError(error, { name, context: 'name_generation' });\n    \n    // Track failed name generation\n    analytics.trackNameGenerated(name, false);\n  } finally {\n    setIsLoading(false);\n  }\n};\n\n// Update share functionality to track sharing\n// In ShareButton component:\nconst handleCopy = async () => {\n  try {\n    await navigator.clipboard.writeText(shareText);\n    setCopied(true);\n    setTimeout(() => setCopied(false), 2000);\n    \n    // Track share via copy\n    analytics.trackShare('copy');\n  } catch (error) {\n    // ...\n  }\n};\n```",
      "testStrategy": "1. Verify analytics events are logged to the console in development\n2. Test that page view events are tracked on initial load\n3. Verify name generation events are tracked with success/failure status\n4. Test error logging with simulated errors\n5. Check that share events are tracked correctly\n6. Verify the analytics API endpoint receives and processes events\n7. Test that analytics and logging don't affect the user experience\n8. Verify that analytics are only enabled in the appropriate environments",
      "priority": "low",
      "dependencies": [6],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement SEO and Metadata",
      "description": "Optimize the application for search engines by adding proper metadata, Open Graph tags, and structured data.",
      "details": "1. Update the root layout.tsx with metadata configuration:\n```tsx\nimport type { Metadata } from 'next';\n\nexport const metadata: Metadata = {\n  title: 'Korean Name Changer - Discover Your Poetic Korean Name',\n  description: 'Transform your foreign name into a meaningful Korean name with deep cultural connections and poetic interpretations.',\n  keywords: ['Korean name', 'name generator', 'Korean culture', 'name meaning', 'Korean translation'],\n  authors: [{ name: 'Korean Name Changer' }],\n  creator: 'Korean Name Changer',\n  publisher: 'Korean Name Changer',\n  formatDetection: {\n    email: false,\n    telephone: false,\n    address: false,\n  },\n  metadataBase: new URL('https://koreannamechanger.com'), // Update with your actual domain\n  alternates: {\n    canonical: '/',\n  },\n  openGraph: {\n    type: 'website',\n    locale: 'en_US',\n    url: 'https://koreannamechanger.com', // Update with your actual domain\n    title: 'Korean Name Changer - Discover Your Poetic Korean Name',\n    description: 'Transform your foreign name into a meaningful Korean name with deep cultural connections and poetic interpretations.',\n    siteName: 'Korean Name Changer',\n    images: [\n      {\n        url: '/og-image.jpg', // Create this image in the public folder\n        width: 1200,\n        height: 630,\n        alt: 'Korean Name Changer',\n      },\n    ],\n  },\n  twitter: {\n    card: 'summary_large_image',\n    title: 'Korean Name Changer - Discover Your Poetic Korean Name',\n    description: 'Transform your foreign name into a meaningful Korean name with deep cultural connections and poetic interpretations.',\n    images: ['/og-image.jpg'], // Same as OpenGraph image\n  },\n  robots: {\n    index: true,\n    follow: true,\n    googleBot: {\n      index: true,\n      follow: true,\n      'max-image-preview': 'large',\n      'max-snippet': -1,\n    },\n  },\n};\n```\n\n2. Create a robots.txt file in the public folder:\n```\nUser-agent: *\nAllow: /\n\nSitemap: https://koreannamechanger.com/sitemap.xml\n```\n\n3. Create a sitemap.xml file in the public folder:\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <url>\n    <loc>https://koreannamechanger.com/</loc>\n    <lastmod>2023-06-18</lastmod>\n    <changefreq>monthly</changefreq>\n    <priority>1.0</priority>\n  </url>\n</urlset>\n```\n\n4. Add structured data for the application in app/structured-data.tsx:\n```tsx\nexport default function StructuredData() {\n  return (\n    <script\n      type=\"application/ld+json\"\n      dangerouslySetInnerHTML={{\n        __html: JSON.stringify({\n          '@context': 'https://schema.org',\n          '@type': 'WebApplication',\n          name: 'Korean Name Changer',\n          description: 'Transform your foreign name into a meaningful Korean name with deep cultural connections and poetic interpretations.',\n          url: 'https://koreannamechanger.com',\n          applicationCategory: 'UtilityApplication',\n          operatingSystem: 'Web',\n          offers: {\n            '@type': 'Offer',\n            price: '0',\n            priceCurrency: 'USD',\n          },\n          inLanguage: 'en',\n          author: {\n            '@type': 'Organization',\n            name: 'Korean Name Changer',\n            url: 'https://koreannamechanger.com',\n          },\n        }),\n      }}\n    />\n  );\n}\n```\n\n5. Include the structured data in the layout:\n```tsx\nimport StructuredData from './structured-data';\n\nexport default function RootLayout({ children }: { children: React.ReactNode }) {\n  return (\n    <html lang=\"en\">\n      <head>\n        <StructuredData />\n      </head>\n      <body>\n        {/* ... */}\n      </body>\n    </html>\n  );\n}\n```\n\n6. Create a manifest.json file in the public folder:\n```json\n{\n  \"name\": \"Korean Name Changer\",\n  \"short_name\": \"KoreanName\",\n  \"description\": \"Transform your foreign name into a meaningful Korean name\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#4f46e5\",\n  \"icons\": [\n    {\n      \"src\": \"/icon-192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"/icon-512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n```\n\n7. Link to the manifest in the layout:\n```tsx\n<link rel=\"manifest\" href=\"/manifest.json\" />\n```",
      "testStrategy": "1. Validate the HTML metadata using tools like the Google Rich Results Test\n2. Check Open Graph tags using Facebook's Sharing Debugger\n3. Validate Twitter Card tags using Twitter's Card Validator\n4. Test structured data using Google's Structured Data Testing Tool\n5. Verify robots.txt and sitemap.xml are accessible and correctly formatted\n6. Check that all URLs in metadata are absolute and correct\n7. Verify manifest.json is valid and properly linked\n8. Test SEO score using tools like Lighthouse or PageSpeed Insights",
      "priority": "medium",
      "dependencies": [2],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Implement Accessibility Features",
      "description": "Enhance the application's accessibility by adding proper ARIA attributes, keyboard navigation, and focus management.",
      "details": "1. Add a skip link for keyboard users in layout.tsx:\n```tsx\n<a \n  href=\"#main-content\" \n  className=\"sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 focus:z-50 focus:px-4 focus:py-2 focus:bg-primary focus:text-primary-foreground focus:rounded-md\"\n>\n  Skip to main content\n</a>\n<main id=\"main-content\" className=\"flex-1\">\n  {children}\n</main>\n```\n\n2. Enhance the NameInputForm component with accessibility features:\n```tsx\n// Add aria-live region for status updates\n<div aria-live=\"polite\" className=\"sr-only\">\n  {isLoading ? 'Generating your Korean name, please wait.' : ''}\n</div>\n\n// Improve form accessibility\n<form \n  onSubmit={handleSubmit} \n  className=\"space-y-4\"\n  aria-label=\"Name input form\"\n>\n  <div>\n    <label htmlFor=\"name-input\" className=\"block text-sm font-medium mb-1\">\n      Your Name\n    </label>\n    <Input \n      id=\"name-input\"\n      placeholder=\"e.g. Isabella Rossellini\" \n      value={name} \n      onChange={(e) => setName(e.target.value)}\n      disabled={isLoading}\n      required\n      aria-required=\"true\"\n      aria-describedby=\"name-hint\"\n    />\n    <p id=\"name-hint\" className=\"text-sm text-muted-foreground mt-1\">\n      Enter your full name or first name only\n    </p>\n  </div>\n  <Button \n    type=\"submit\" \n    className=\"w-full\" \n    disabled={isLoading || !name.trim()}\n    aria-busy={isLoading}\n  >\n    {isLoading ? 'Generating...' : 'Generate Korean Name'}\n  </Button>\n</form>\n```\n\n3. Improve the ResultCard component accessibility:\n```tsx\n<Card className=\"w-full max-w-2xl mx-auto\" ref={ref}>\n  <CardHeader>\n    <CardTitle className=\"text-center\" tabIndex={0}>{result.korean_name}</CardTitle>\n    <CardDescription className=\"text-center\" tabIndex={0}>Korean name for {result.original_name}</CardDescription>\n  </CardHeader>\n  <CardContent className=\"space-y-6\">\n    <div>\n      <h3 className=\"text-lg font-semibold mb-2\" tabIndex={0}>Connection</h3>\n      <p tabIndex={0}>{result.connection_explanation}</p>\n    </div>\n    \n    <Separator aria-hidden=\"true\" />\n    \n    <div>\n      <h3 className=\"text-lg font-semibold mb-2\" tabIndex={0}>Hanja Characters</h3>\n      <div \n        className=\"grid grid-cols-1 md:grid-cols-3 gap-4\"\n        role=\"list\"\n        aria-label=\"Hanja character breakdown\"\n      >\n        {result.hanja_breakdown.map((hanja, index) => (\n          <div \n            key={index} \n            className=\"border rounded-lg p-4 text-center\"\n            role=\"listitem\"\n            tabIndex={0}\n          >\n            <div className=\"text-3xl mb-2\" aria-label={`Hanja character: ${hanja.character}`}>\n              {hanja.character}\n            </div>\n            <p className=\"text-sm\">{hanja.meaning}</p>\n          </div>\n        ))}\n      </div>\n    </div>\n    \n    <Separator aria-hidden=\"true\" />\n    \n    <div>\n      <h3 className=\"text-lg font-semibold mb-2\" tabIndex={0}>Poetic Interpretation</h3>\n      <p className=\"italic\" tabIndex={0}>{result.poetic_interpretation}</p>\n    </div>\n  </CardContent>\n</Card>\n```\n\n4. Implement focus management when transitioning between views:\n```tsx\n// Add to imports\nimport { useRef, useEffect } from 'react';\n\n// Inside the HomePage component\nconst nameInputRef = useRef<HTMLInputElement>(null);\nconst resultRef = useRef<HTMLDivElement>(null);\n\n// Focus the input when the component mounts\nuseEffect(() => {\n  if (!result && nameInputRef.current) {\n    nameInputRef.current.focus();\n  }\n}, [result]);\n\n// Focus the result when it's displayed\nuseEffect(() => {\n  if (result && resultRef.current) {\n    resultRef.current.focus();\n  }\n}, [result]);\n\n// Update the NameInputForm to accept and use the ref\n<NameInputForm \n  onSubmit={handleSubmit} \n  isLoading={isLoading} \n  inputRef={nameInputRef} \n/>\n\n// Update the ResultCard to accept and use the ref\n<ResultCard \n  result={result} \n  ref={resultCardRef} \n  focusRef={resultRef} \n/>\n```\n\n5. Add keyboard shortcuts for common actions:\n```tsx\n// Add to imports\nimport { useEffect } from 'react';\n\n// Inside the HomePage component\nuseEffect(() => {\n  const handleKeyDown = (e: KeyboardEvent) => {\n    // Alt+N to focus the name input\n    if (e.altKey && e.key === 'n' && !result) {\n      e.preventDefault();\n      nameInputRef.current?.focus();\n    }\n    \n    // Alt+G to generate (if input has value)\n    if (e.altKey && e.key === 'g' && !result && !isLoading) {\n      e.preventDefault();\n      const inputValue = nameInputRef.current?.value;\n      if (inputValue) {\n        handleSubmit(inputValue);\n      }\n    }\n    \n    // Alt+R to reset/try again\n    if (e.altKey && e.key === 'r' && result) {\n      e.preventDefault();\n      handleReset();\n    }\n  };\n  \n  window.addEventListener('keydown', handleKeyDown);\n  return () => window.removeEventListener('keydown', handleKeyDown);\n}, [result, isLoading, handleSubmit, handleReset]);\n```\n\n6. Add a visually hidden accessibility info section:\n```tsx\n<div className=\"sr-only\" aria-live=\"polite\">\n  <h2>Keyboard Shortcuts</h2>\n  <ul>\n    <li>Alt+N: Focus the name input</li>\n    <li>Alt+G: Generate Korean name</li>\n    <li>Alt+R: Try another name</li>\n  </ul>\n</div>\n```",
      "testStrategy": "1. Test keyboard navigation throughout the application\n2. Verify screen reader compatibility using tools like NVDA or VoiceOver\n3. Check focus management when transitioning between views\n4. Test keyboard shortcuts functionality\n5. Verify ARIA attributes are correctly implemented\n6. Run accessibility audits using tools like Lighthouse or axe\n7. Test with high contrast mode and zoom settings\n8. Verify that all interactive elements have appropriate focus states",
      "priority": "medium",
      "dependencies": [6],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Prepare for Deployment",
      "description": "Prepare the application for production deployment, including environment configuration, build optimization, and deployment setup.",
      "details": "1. Create environment configuration files:\n   - .env.local (for local development)\n   - .env.production (for production settings)\n   - .env.example (as a template for other developers)\n\n2. Example .env.example file:\n```\n# API Keys\nGEMINI_API_KEY=your_api_key_here\n\n# Feature Flags\nUSE_REAL_API=true\nNEXT_PUBLIC_ENABLE_ANALYTICS=true\nNEXT_PUBLIC_DISABLE_ERROR_LOGGING=false\n\n# Deployment\nNEXT_PUBLIC_SITE_URL=https://koreannamechanger.com\n```\n\n3. Create a next.config.js file with optimizations:\n```javascript\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify: true,\n  images: {\n    domains: [],\n    formats: ['image/avif', 'image/webp'],\n  },\n  // Enable compression\n  compress: true,\n  // Configure headers for security\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'X-Content-Type-Options',\n            value: 'nosniff',\n          },\n          {\n            key: 'X-Frame-Options',\n            value: 'DENY',\n          },\n          {\n            key: 'X-XSS-Protection',\n            value: '1; mode=block',\n          },\n          {\n            key: 'Referrer-Policy',\n            value: 'strict-origin-when-cross-origin',\n          },\n        ],\n      },\n    ];\n  },\n  // Configure redirects if needed\n  async redirects() {\n    return [];\n  },\n  // Configure rewrites if needed\n  async rewrites() {\n    return [];\n  },\n};\n\nmodule.exports = nextConfig;\n```\n\n4. Create a package.json scripts section for deployment:\n```json\n\"scripts\": {\n  \"dev\": \"next dev\",\n  \"build\": \"next build\",\n  \"start\": \"next start\",\n  \"lint\": \"next lint\",\n  \"analyze\": \"ANALYZE=true next build\",\n  \"postbuild\": \"next-sitemap\"\n}\n```\n\n5. Install additional deployment-related packages:\n```bash\nnpm install --save-dev next-sitemap cross-env\n```\n\n6. Create a next-sitemap.config.js file:\n```javascript\n/** @type {import('next-sitemap').IConfig} */\nmodule.exports = {\n  siteUrl: process.env.NEXT_PUBLIC_SITE_URL || 'https://koreannamechanger.com',\n  generateRobotsTxt: true,\n  robotsTxtOptions: {\n    additionalSitemaps: [\n      `${process.env.NEXT_PUBLIC_SITE_URL || 'https://koreannamechanger.com'}/sitemap.xml`,\n    ],\n  },\n};\n```\n\n7. Create a Vercel configuration file (vercel.json):\n```json\n{\n  \"version\": 2,\n  \"buildCommand\": \"npm run build\",\n  \"installCommand\": \"npm install\",\n  \"framework\": \"nextjs\",\n  \"regions\": [\"iad1\"],\n  \"env\": {\n    \"GEMINI_API_KEY\": \"@gemini-api-key\"\n  }\n}\n```\n\n8. Create a README.md file with setup and deployment instructions:\n```markdown\n# Korean Name Changer\n\nA web application that transforms foreign names into meaningful Korean names with poetic interpretations.\n\n## Features\n\n- Generate Korean names based on the meaning and essence of foreign names\n- View detailed explanations of the name's connection to the original name\n- See Hanja character breakdowns with meanings\n- Read poetic interpretations of the generated names\n- Save and view previously generated names within a session\n\n## Tech Stack\n\n- Next.js (App Router)\n- Shadcn UI\n- Tailwind CSS\n- Google Gemini API\n\n## Getting Started\n\n### Prerequisites\n\n- Node.js 18+ and npm\n- Google Gemini API key\n\n### Installation\n\n1. Clone the repository\n   ```bash\n   git clone https://github.com/yourusername/korean-name-changer.git\n   cd korean-name-changer\n   ```\n\n2. Install dependencies\n   ```bash\n   npm install\n   ```\n\n3. Create a `.env.local` file based on `.env.example`\n   ```bash\n   cp .env.example .env.local\n   ```\n\n4. Add your Google Gemini API key to `.env.local`\n\n5. Start the development server\n   ```bash\n   npm run dev\n   ```\n\n6. Open [http://localhost:3000](http://localhost:3000) in your browser\n\n## Deployment\n\n### Vercel (Recommended)\n\n1. Push your code to a GitHub repository\n\n2. Import the project in Vercel\n\n3. Add the required environment variables\n\n4. Deploy\n\n### Manual Deployment\n\n1. Build the application\n   ```bash\n   npm run build\n   ```\n\n2. Start the production server\n   ```bash\n   npm start\n   ```\n\n## License\n\nMIT\n```",
      "testStrategy": "1. Verify the application builds successfully with `npm run build`\n2. Test the production build locally with `npm start`\n3. Check environment variables are correctly loaded in different environments\n4. Verify security headers are applied correctly\n5. Test the sitemap generation process\n6. Check for any build warnings or performance issues\n7. Verify the application works with production API settings\n8. Test deployment to Vercel or other hosting platforms\n9. Verify the README instructions are accurate and complete",
      "priority": "high",
      "dependencies": [1, 2, 3, 4, 5, 6],
      "status": "done",
      "subtasks": []
    }
  ]
}
