# Task ID: 5
# Title: Setup Gemini API Integration
# Status: done
# Dependencies: 1
# Priority: high
# Description: Implement the integration with Google Gemini API to generate Korean names based on user input, including proper error handling and response parsing.
# Details:
1. Create a .env.local file to store the Gemini API key:
```
GEMINI_API_KEY_FREE=your_api_key_here
```
2. Install the Google Generative AI SDK:
```bash
npm install @google/generative-ai
```
3. Create a lib/gemini.ts file for API integration:
```typescript
import { GoogleGenerativeAI } from '@google/generative-ai';

// Initialize the Gemini API client
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY_FREE || '');

// Define the expected response structure
export interface KoreanNameResult {
  original_name: string;
  korean_name: string;
  connection_explanation: string;
  hanja_breakdown: {
    character: string;
    meaning: string;
  }[];
  poetic_interpretation: string;
}

// Create the system prompt
const systemPrompt = `You are a poetic Korean name generator that creates meaningful Korean names for foreigners.
When given a foreign name, analyze its etymology, meaning, and cultural significance.
Then create a Korean name (including surname) that captures the essence and meaning of the original name.
Your response must be a valid JSON object with the following structure:
{
  "original_name": "The input name",
  "korean_name": "The Korean name with Hanja and romanization in parentheses",
  "connection_explanation": "Detailed explanation of how the Korean name connects to the original name",
  "hanja_breakdown": [
    {
      "character": "The Hanja character",
      "meaning": "The meaning of this specific Hanja character"
    }
  ],
  "poetic_interpretation": "A poetic description of the name's overall meaning and imagery"
}
Use traditional and meaningful Korean surnames like Kim, Lee, Park, Choi, etc.
Choose Hanja characters that have positive meanings and are commonly used in Korean names.
Provide romanization in the Revised Romanization system.
Make the connection between the original name and Korean name meaningful, not just phonetic.`;

export async function generateKoreanName(foreignName: string): Promise<KoreanNameResult> {
  try {
    // Get the Gemini Pro model
    const model = genAI.getGenerativeModel({ model: 'gemini-pro' });
    
    // Generate content with the system prompt and user input
    const result = await model.generateContent([
      systemPrompt,
      `Generate a Korean name for: ${foreignName}`
    ]);
    
    const response = result.response;
    const text = response.text();
    
    // Parse the JSON response
    try {
      const parsedResult = JSON.parse(text) as KoreanNameResult;
      return parsedResult;
    } catch (parseError) {
      console.error('Failed to parse Gemini API response:', parseError);
      throw new Error('Invalid response format from AI service');
    }
  } catch (error) {
    console.error('Error calling Gemini API:', error);
    throw new Error('Failed to generate Korean name');
  }
}
```
4. Create an API route in app/api/generate-name/route.ts:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { generateKoreanName } from '@/lib/gemini';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { name } = body;
    
    if (!name || typeof name !== 'string') {
      return NextResponse.json(
        { error: 'Name is required' },
        { status: 400 }
      );
    }
    
    const result = await generateKoreanName(name);
    return NextResponse.json(result);
  } catch (error) {
    console.error('Error in generate-name API route:', error);
    return NextResponse.json(
      { error: 'Failed to generate Korean name' },
      { status: 500 }
    );
  }
}
```

# Test Strategy:
1. Test the API integration with valid input names
2. Verify error handling for API failures
3. Test response parsing with sample JSON responses
4. Check handling of rate limiting and other API constraints
5. Verify the API route returns proper error responses for invalid inputs
6. Test with various name formats (first name only, full name, names with special characters)
7. Create a mock implementation for development and testing purposes
